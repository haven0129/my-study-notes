# GC

## 基础知识

### 什么是垃圾

- 一个对象，没有任何引用指向他，那么这个对象就是垃圾。
- 对象之间互相引用，但是没有任何栈空间的引用指向他们，那么这就是一堆垃圾。

### java分配内存

- 使用new关键字

### Java释放内存

- 自动回收,编程上简单，系统不容易出错，手动释放内存容易出两种类型的问题

	- 忘了回收
	- 多次回收

## 如何定位垃圾

### 引用计数（不能解决循环引用的问题）

### 根可达算法（root searching）

## GC Roots

### 线程栈变量

### 静态变量

### 常量池

### JNI指针

## 垃圾回收算法

### 标记清除（Mark-Sweep）

- 位置不连续，产生碎片

### 拷贝(Copying)

- 没有碎片，浪费空间

### 标记压缩(Mark-Compact)

- 不浪费空间，内存连续，但是效率低。

## JVM内存分代模型

### 新生代

YGC回收之后，大多数的对象会被回收，活着的进入s0
再次YGC，活着的对象eden + s0 进入到 s1
再次YGC，eden + s1 进入s0
年龄足够的进入 老年代 
s区装不下的进入 老年代
老年代满了就FGC(Full GC)

- Eden(伊甸)
- suvivor0
- suvivor1

### 老年代

### 永久代（jdk1.7）

永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）
字符串常量在jdk1.7放在永久代，jdk1.8放到堆空间

- 存放元数据（Class）

### 元数据区(jdk1.8)Metaspace

## 常见垃圾回收器

### Serial 

- 年轻代
- 串行回收

### PS

- 年轻代
- 并行回收

### ParNew

- 年轻代
- 配合CMS的并行回收

### SerialOld

### ParallelOld

### ConcurrentMarkSweep

- 老年代
- 垃圾回收和应用程序同时运行

### G1

### ZGC

### Shenandoah

### Eplison

*XMind - Trial Version*