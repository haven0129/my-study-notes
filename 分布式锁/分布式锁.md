# 分布式锁

## 场景

### 银行账户同时取款和转账

### 多个用户同时购物，库存不足的情况

## 分布式锁执行流程

### 1、获取锁

### 2、查看锁状态

如果锁已被占用，则重试直到获取锁成功

### 3、给共享变量上锁

### 4、业务操作

如果业务操作超时，那么自动释放锁

### 5、释放锁

## 分布式锁具备条件

### 互斥性

- 同一时刻只有一个服务访问资源，特殊情况有读写锁

### 原子性

- 要求加锁和解锁的流程是原子性的

### 安全性

- 锁只能被持有该锁的服务释放

### 容错性

- 持有锁的服务崩溃时，仍然能够释放锁，避免死锁

### 可重用性

- 同一个服务获得锁后，可重复上锁（重入锁和不可重入锁），但是上多少次锁就要释放多少次锁

### 公平性

- 看业务是否需要公平（公平锁和非公平锁）

### 支持阻塞和非阻塞

- 阻塞

	- 获取锁的时候如果未获取到会一直循环获取

- 非阻塞

	- 不会一直循环获取锁，尝试固定次数或时间后放弃

### 高可用

- 获取和释放锁要高可用

### 高性能

- 获取和释放锁性能要好（速度快）

### 持久性

- 按业务需要允许锁的持有者对锁的有效期进行自动续约/自动延期（比如业务执行需要10s，但是锁的有效期只有2s的情况）

## 实现方式

### 基于数据库实现

- 基于数据库表（基于唯一约束）

	- 实现步骤

		- 1、访问数据时，将程序编号插入表
		- 2、如果插入成功，就表示获得了锁
		- 3、当其他程序插入时，由于插入相同程序编号，导致插入失败就表示获取锁失败
		- 4、获取锁成功的程序，在业务执行完后删除该数据表示释放锁

- 基于数据库排他锁

	- 实现步骤

		- 1、在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁，当某条记录被加上排他锁之后，其他线程无法再在该记录上增加排他锁
		- 2、获得排他锁的线程即可获得分布式锁，执行方法的业务逻辑
		- 3、执行完成之后，通过connection.commit()方法来释放锁

### 基于缓存（Redis等）实现

- 实现原理

	- 1、redis提供的SETNX key value方法，当一个线程执行setnx返回1，说明key不存在，该线程获得锁；当一个线程执行setnx返回0，说明key已经存在，则获取锁失败。
	- 2、redis提供的的EXPIRE()方法，设置key在redis中的有效期。防止系统或程序崩溃之后，无法删除key导致的死锁
	- 3、redis提供的GETSET()方法，该方法是原子的，使用该方法对锁进行延期。

### 基于Zookeeper实现

- zookeeper相关特质

	- 有序节点

	  假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号，也就是说如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。

	- 临时节点

	  客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。

	- 事件监听

	  在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper有如下四种事件：1）节点创建；2）节点删除；3）节点数据修改；4）子节点变更。

- 原理

	- 每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。
	- 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。
	- 同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题

- 解决的问题

	- 锁无法释放问题

	  使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁

	- 非阻塞锁问题

	  使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。

	- 不可重入问题

	  使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。

	- 单点问题

	  使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。

### 总结

- 理解难度

	- 数据库<缓存<zookper

- 实现复杂度

	- 数据库<缓存<=zookeeper

- 性能

	- 数据库<zookpeeper<缓存

- 可靠性

	- 数据库<缓存<zookeeper

*XMind - Trial Version*