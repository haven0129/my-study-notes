# JVM

## jvm体系架构

jvm是运行在操作系统上的，它与硬件没有直接交互

### 运行时数据区（Runtime Data Area）

- 方法区(Method Area)

  供各线程共享的运行时内存区域，它存储了每一个类的结构信息，例如运行时的常量池，字段和方法数据、构造函数和普通方法的字节码内容。
  
  方法区是规范，在不同虚拟机中实现是不一样的，典型的是永久代和元空间。

- 堆（Heap）
- java栈(JAVA Stack)
- 本地方法栈(Native Method Area)

  登记native方法，在Exection Engine执行时加载本地方法库

- 程序计数器，又叫PC寄存器(Program Counter Register)

  每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码，（用来存储指向下一条指令的地址）由执行引擎读取下一条指令，是一个非常狭小的内存空间，几乎可以忽略不计。
  
  这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。
  
  如果执行一个Native方法，那这个计数器是空的。
  
  用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存泄漏错误（OutOfMemory=OOM）

### 类装载器(ClassLoader)

- 作用

	- 负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码加载到内存中，并将这些内容转换为方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，至于它是否能够运行，由执行引擎(Exection Engine)决定

- 自带类加载器

	- 启动类加载器BootstrapLoader

		- jdk自带类使用

	- 扩展类加载器ExetensionLoader

		- jdk扩展类使用

	- 应用程序类加载器（AppClassLoader）

		- 自定义类使用

	- 用户自定义加载器

- 双亲委派机制

  当类加载器加载一个class文件时，总是先询问自己的父类加载器是否能够加载这个class文件，如果自己的父类加载器可以加载，那么就交给父类加载器，如果父类不可以，则自己加载。
  
  所以类加载时，总是在启动类加载器加载，如果没找到，再区扩展类加载器加载，最后才会加载自己。还找不到就报CLASS NOT FOUND EXCEPTION
  
  安全性:沙箱安全机制

### 本地方法接口(Native Interface)

- 本地方法是为了融合不同的语言为java所用，调用其他语言的方法，专门开辟了一块内存空间，处理标记为native的代码。运行时放到本地方法栈中

### 执行引擎(Exection Engine)

- 负责解释命令，提交给操作系统执行

## 栈Stack

栈也叫栈内存，主管java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题。只要在线程一结束栈就over，生命周期和线程一致，是线程私有的。

8中基本数据类型+

### 相关知识

- 栈管运行，堆管存储
- 队列

	- 先进先出

- 栈

	- 先进后出

### 栈存储

- 8种基本数据类型的变量
- 对象的引用变量
- 实例方法

### 栈帧

栈中的数据都是以栈帧的格式存在，栈帧是一个内存区块，是一个有关方法和运行期数据的数据集，遵循先进先出的原则。

每个方法执行的同时都会创建一个栈帧，用户存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完毕的过程都对应着一个栈帧在虚拟机中入栈到出栈的过程。

栈的大小和具体的jvm有关通常在256-756k之间。

- 本地变量

	- 输入参数，输出参数，以及方法内的变量

- 栈操作

	- 记录出栈入栈操作

- 栈帧数据

	- 包括类文件、方法等

### 栈顶

- 当前方法

## 堆参数调优

## 堆Heap体系架构

一个jvm实例只存在一个堆内存，堆内存大小是可以调节的，类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行

### 逻辑分区

伊甸区满了，触发YGC
YGC回收之后，大多数的对象会被回收，活着的进入s0
再次YGC，活着的对象eden + s0 进入到 s1
再次YGC，eden + s1 进入s0
年龄足够的进入 老年代 （一般默认15次，可以通过修改jvm参数MaxTenuringThreshold）
s区装不下的进入 老年代
老年代满了就FGC(Full GC)
   8.永久代满了就会堆内存溢出

通过Jvm参数-xms -xmx来指定堆内存大小

- 新生代

	- Eden(伊甸区)
	- suvivor0(幸存区)
	- suvivor1(幸存区)

- 老年代)
- 永久代/元空间

  HotSpot虚拟机中，永久代/元空间是方法区的一个实现（类似于一个interface的实现）

	- jdk1.7是永久代，jdk1.8换成元空间

### 物理分区

- 新生区(1/3堆空间)

	- 伊甸（8/10）
	- 幸存0（1/10）
	- 幸存1（1/10）

- 养老区(2/3堆空间

*XMind - Trial Version*