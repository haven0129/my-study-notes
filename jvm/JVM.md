# JVM

## jvm体系架构

jvm是运行在操作系统上的，它与硬件没有直接交互

### 类装载器(ClassLoader)

- 作用

	- 负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码加载到内存中，并将这些内容转换为方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，至于它是否能够运行，由执行引擎(Exection Engine)决定

- 自带类加载器

	- 启动类加载器BootstrapLoader

		- jdk自带类使用

	- 扩展类加载器ExetensionLoader

		- jdk扩展类使用

	- 应用程序类加载器（AppClassLoader）

		- 自定义类使用

	- 用户自定义加载器

- 双亲委派机制

  当类加载器加载一个class文件时，总是先询问自己的父类加载器是否能够加载这个class文件，如果自己的父类加载器可以加载，那么就交给父类加载器，如果父类不可以，则自己加载。
  
  所以类加载时，总是在启动类加载器加载，如果没找到，再区扩展类加载器加载，最后才会加载自己。还找不到就报CLASS NOT FOUND EXCEPTION
  
  安全性:沙箱安全机制

### 运行时数据区（Runtime Data Area）

- 方法区(Method Area)

  供各线程共享的运行时内存区域，它存储了每一个类的结构信息，例如运行时的常量池，字段和方法数据、构造函数和普通方法的字节码内容。
  
  方法区是规范，在不同虚拟机中实现是不一样的，典型的是永久代和元空间。

- 堆（Heap）
- java栈(JAVA Stack)
- 本地方法栈(Native Method Area)

  登记native方法，在Exection Engine执行时加载本地方法库

- 程序计数器，又叫PC寄存器(Program Counter Register)

  每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码，（用来存储指向下一条指令的地址）由执行引擎读取下一条指令，是一个非常狭小的内存空间，几乎可以忽略不计。
  
  这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。
  
  如果执行一个Native方法，那这个计数器是空的。
  
  用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存泄漏错误（OutOfMemory=OOM）

### 本地方法接口(Native Interface)

- 本地方法是为了融合不同的语言为java所用，调用其他语言的方法，专门开辟了一块内存空间，处理标记为native的代码。运行时放到本地方法栈中

### 执行引擎(Exection Engine)

- 负责解释命令，提交给操作系统执行

## 栈Stack

栈也叫栈内存，主管java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题。只要在线程一结束栈就over，生命周期和线程一致，是线程私有的。

8中基本数据类型+

### 相关知识

- 栈管运行，堆管存储
- 队列

	- 先进先出

- 栈

	- 先进后出

### 栈存储

- 8种基本数据类型的变量
- 对象的引用变量
- 实例方法

### 栈帧

栈中的数据都是以栈帧的格式存在，栈帧是一个内存区块，是一个有关方法和运行期数据的数据集，遵循先进先出的原则。

每个方法执行的同时都会创建一个栈帧，用户存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完毕的过程都对应着一个栈帧在虚拟机中入栈到出栈的过程。

栈的大小和具体的jvm有关通常在256-756k之间。

- 本地变量

	- 输入参数，输出参数，以及方法内的变量

- 栈操作

	- 记录出栈入栈操作

- 栈帧数据

	- 包括类文件、方法等

### 栈顶

- 当前方法

## GC

### 分代回收算法原则

- 次数上频繁收集Young区(YGC)
- 次数上较少收集Old区(FGC)
- 基本不动元空间

### GC分类

- YGC=YoungGc=MinorGC

	- 发生在Young区

- FGC=FullGC=MajorGC

	- 堆区全局GC

### 垃圾回收算法

- 引用计数

	- 较难处理循环引用

- 标记清除（Mark-Sweep）

	- 位置不连续，产生碎片

- 拷贝(Copying)

	- 没有碎片，浪费空间，应用于YGC

- 标记压缩(Mark-Compact)

	- 不浪费空间，内存连续，但是效率低。

### 常见垃圾回收器

- PS

	- 年轻代
	- 并行回收

- ParNew

	- 年轻代
	- 配合CMS的并行回收

- SerialOld
- ParallelOld
- ConcurrentMarkSweep

	- 老年代
	- 垃圾回收和应用程序同时运行

- G1
- ZGC
- Shenandoah
- Eplison

## jvm参数

### 常用参数

- heap参数

	- -Xms

		- 堆初始化时内存分配大小，如不指定，默认为物理内存的1/64

	- -Xmx

		- 堆运行时最大内存分配大小，如不指定，默认为物理内存的1/4

- 新生代参数

	- -Xmn

		- 新生区和养老区的比例，一般不调整，默认年轻代/老年代内存分配：1/2

- 永久代参数（jdk1.7）

	- -XX:PermSize

		- 永久代初始化内存大小

	- -XX:MaxPermSize

		- 永久代最大内存大小

- -XX:+PrintGCDetails

	- 输出详细GC处理日志

- -Xloggc:

	- 指定GC log的位置，例如-Xloggc:log/gc.log

## 堆Heap体系架构

一个jvm实例只存在一个堆内存，堆内存大小是可以调节的，类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行

### 逻辑分区

伊甸区满了，触发YGC
YGC回收之后，大多数的对象会被回收，活着的进入s0
再次YGC，活着的对象eden + s0 进入到 s1
再次YGC，eden + s1 进入s0
年龄足够的进入 老年代 （一般默认15次，可以通过修改jvm参数MaxTenuringThreshold）
s区装不下的进入 老年代
老年代满了就FGC(Full GC)
如果进行了多次FGC之后，还是无法腾出养老区的空间，就会报OOM（out of Memory）异常

通过Jvm参数-xms -xmx来指定堆内存大小

- 新生代

	- Eden(伊甸区)
	- suvivor0(幸存区)
	- suvivor1(幸存区)

- 老年代)
- 永久代/元空间

  HotSpot虚拟机中，永久代/元空间是方法区的一个实现（类似于一个interface的实现）
  
  永久代：是一个常驻的内存区域，用于存放JDK自身所携带的Class,Interface的元数据，它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收的，关闭jvm才能释放此区域所占用的内存。
  
  元空间：在java8中，永久代被移除，被元空间所取代，元空间和永久代本质类似。
  区别：永久代使用jvm堆内存，元空间并不在虚拟机中，而是使用本机物理内存。
  
  默认情况下，元空间大小仅受本地内存限制。类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。

	- jdk1.7是永久代，jdk1.8换成元空间

### 物理分区

- 新生区(1/3堆空间)

	- 伊甸（8/10）
	- 幸存0（1/10）
	- 幸存1（1/10）

- 养老区(2/3堆空间

*XMind - Trial Version*